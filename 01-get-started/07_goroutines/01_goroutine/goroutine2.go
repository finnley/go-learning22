package main

import (
	"fmt"
	"time"
)

func main2() {
	for i := 0; i < 100; i++ {
		// 闭包: 可以换个角度看，将里面的匿名函数当做一个整体F,F已经是一个协程了，那这个协程怎么能使用到另一个协程中的变量呢？
		// 但是现实确实使用到了，而且还能够使用
		// 主协程中的变量i, 在主协程中需要生成100个子协程，这些子协程要打印i，而这个i并不是子协程中定义的，这个主协程中的i又是随时变化的
		// 比如当 i = 1 的时候启动了一个协程A，然后i继续叠加，但是A协程打印的时候i已经变成了5，其他子协程同样的也有可能是5
		// 调度的时候不好确定i已经是什么值的
		go func() {
			for {
				fmt.Println(i)
				time.Sleep(time.Second)
			}
		}()
	}
	time.Sleep(time.Second * 2)
}

func main() {
	for i := 0; i < 100; i++ {
		// 修改成下面传参形式可以去到没有协程打印的都不一样
		// 这样传参在生成子协程A的时候，因为要接收一个参数，比如现在 i=2, 所以会将 i 拷贝一份传给A，A就会打印1
		// 在i=3的时候会生成子协程B，通过的将i=2赋值一份传进去，此时 B协程就会打印2
		// 在调用的时候互不影响，因为会优先使用门口复制过来的i
		go func(i int) {
			fmt.Println(i)
		}(i)
	}
	time.Sleep(time.Second * 2)
	// 顺序不一致的原因：对于协程来说，不是先启动的协程就一定会先运行
}
