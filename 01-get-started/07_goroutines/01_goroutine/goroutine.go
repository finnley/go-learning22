/**
Go语言诞生的比较晚，在原生支持并发是有优势的
最开始处理高并发场景：
多进程   -  多线程	- 	协程
现在主流的还是多线程
但是多线程会存在一些缺点：每个线程占用的内存比较多，而且系统切换开销很大

用户态线程：
一台电脑中要并发执行很多任务，也就是不停的去开启多个线程，多个线程在操作系统运行的时候，每个线程切换的时候是有成本的，而且线程会占用一定数量，
当线程开启过多的时候系统是承受不了的，比如内存不够，开销很大，这种线程一般对应的操作系统级别的线程，所以在后续的发展中提出很多要求，
这个线程能不能变成我们的程序一样，比如一个协程就是一个函数，类似这样的逻辑

如果协程像函数一样级别，那函数之间的切换就不是由操作系统来做，其实是不需要深入内核去进行切换的，它在编译的时候或者程序运行中就可以完成两个函数之间的调用
*/
package main

import (
	"fmt"
	"time"
)

func p() {
	fmt.Println("golang")
}

func main() {
	// 直接运行没有任何输出
	// 这是因为运行 main 函数会启动一个主线程或者主协程，当使用 go func()的时候是将一个程序放到一个协程中运行，但是 main 本身也是一个协程
	// 主协程和子协程是并发运行的
	// 下面两行代码输出结果有时只有 main(大多情况下)，这是因为 主死从随，主协程打印一旦运行结束之后主协程就退出了，但是 go func是主线程里面开辟出来的生成的子协程，主协程一旦死了，从协程也会跟着挂，如果想要输出 golang 就要保证主协程不会挂，可以使用 sleep
	// 但有时候是 golang main
	//go p()
	//fmt.Println("main")

	// 下面使用 sleep 睡几秒，主协程就不会立马挂掉，从协程就会有机会运行，2s钟一到就结束了
	go p()
	time.Sleep(time.Second * 2)
	fmt.Println("main")
}
