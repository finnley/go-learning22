package main

func main() {
	var msg chan int
	msg = make(chan int)
	// 但是现在这个是没有缓冲区的，就要等有人消费才能释放锁
	// channel 是多个goroutine之间线程安全的，也就是多个 goroutine 对同一个channel 进行操作是不会出现并发的数据一致性问题， 这背后如何保证的？肯定是使用了锁，why?
	// 当进行放数据到 msg 中的时候，这个时候会阻塞的，阻塞之前会获取一把锁，现在还没有人来竞争锁，因为没有goroutine,获取之后就要等，等别人消费，
	// 那这把锁什么时候释放，肯定是要等到数据被消费之后，因为这个channel是没有缓冲空间的，如果要进行下一步操作，肯定是要等到对方消费完之后，才敢把这把锁释放，有缓冲区会放缓冲区，放完之后就立马释放锁，但现在是无缓冲区的：
	/**
	1.获取锁
	2.等待消费者消费
	3.释放锁

	第二步就不能成功，因为现在根本没有消费者，就无法释放锁

	一般情况下可以这样理解死锁
	比如现在有两把锁，有两个协程
	A协程：										B协程：
	1.先获取A锁 ====== A获取A锁，B获取B锁 =====>	1.先获取B锁
	2.再获取B锁 ==== 等待B协程释放B锁 ========>		2.再获取A锁
	3.逻辑处理  <==== 等待A协程释放A锁 ========		3.逻辑处理
	4.释放B锁									4.释放A锁
	5.释放A锁									5.释放B锁

	现在两个协程同时运行完， A正好获取到了A锁之后，goroutine切换了，B获取到了B锁，
	对于 A goroutine,A就再获取B说，B就获取A锁，此时A的goroutine能获取到B锁吗？是不可能的，因为B的goroutine已经获取到了，锁没有释放，所以A的goroutine就会等到B锁的释放，
	对于 B goroutine,它要获取A锁，就要等待A goroutine释放A锁
	*/

	// 如果是一个没有缓冲的 channel,在没有启动一个消费者之前，放数据就会报错，除非在放数据之前启动了一个 goroutine 从这个channel中获取数据
	msg <- 1
	//data := <-msg
	//fmt.Println(data)
}
